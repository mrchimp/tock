{"version":3,"file":"tock.js","mappings":"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","sources":["webpack://Tock/webpack/universalModuleDefinition","webpack://Tock/webpack/bootstrap","webpack://Tock/webpack/runtime/define property getters","webpack://Tock/webpack/runtime/hasOwnProperty shorthand","webpack://Tock/webpack/runtime/make namespace object","webpack://Tock/./src/lib/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tock\"] = factory();\n\telse\n\t\troot[\"Tock\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Tock by Mr Chimp - github.com/mrchimp/tock\n * Based on code by James Edwards:\n *    sitepoint.com/creating-accurate-timers-in-javascript/\n */\n\nimport { TockOptions } from \"../types/TockOptions\";\n\nconst MILLISECONDS_RE = /^\\s*(\\+|-)?\\d+\\s*$/;\nconst MM_SS_RE = /^(\\d{1,2}):(\\d{2})$/;\nconst MM_SS_ms_OR_HH_MM_SS_RE = /^(\\d{1,2}):(\\d{2})(?::|\\.)(\\d{2,3})$/;\nconst MS_PER_HOUR = 3600000;\nconst MS_PER_MIN = 60000;\nconst MS_PER_SEC = 1000;\n\n/* The RegExp below will match a date in format `yyyy-mm-dd HH:MM:SS` and optionally with `.ms` at the end.\n * It will also match ISO date string, i.e. if the whitespace separator in the middle is replaced with a `T`\n * and the date string is also suffixed with a `Z` denoting UTC timezone.\n */\nconst yyyy_mm_dd_HH_MM_SS_ms_RE =\n  /^(\\d{4})-([0-1]\\d)-([0-3]\\d)(?:\\s|T)(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{3})Z?)?$/;\n\nclass Tock {\n  go: boolean;\n  timeout: number | undefined;\n  missed_ticks: null | number;\n  interval: number;\n  countdown: boolean;\n  start_time: number;\n  pause_time: number;\n  final_time: number;\n  duration_ms: number;\n  time: number;\n  callback: (self: this) => void;\n  complete: (self: this) => void;\n\n  constructor(options: TockOptions = {}) {\n    this.go = false;\n    this.timeout = undefined;\n    this.missed_ticks = null;\n    this.interval = options.interval || 10;\n    this.countdown = options.countdown || false;\n    this.start_time = 0;\n    this.pause_time = 0;\n    this.final_time = 0;\n    this.duration_ms = 0;\n    this.time = 0;\n    this.callback = options.callback || function () {};\n    this.complete = options.complete || function () {};\n  }\n\n  /**\n   * Called every tick for countdown clocks.\n   * i.e. once every this.interval ms\n   */\n  #tick() {\n    this.time += this.interval;\n\n    if (this.countdown && this.duration_ms - this.time < 0) {\n      this.final_time = 0;\n      this.go = false;\n      this.callback(this);\n      clearTimeout(this.timeout);\n      this.complete(this);\n      return;\n    } else {\n      this.callback(this);\n    }\n\n    var diff = Date.now() - this.start_time - this.time,\n      next_interval_in = diff > 0 ? this.interval - diff : this.interval;\n\n    if (next_interval_in <= 0) {\n      this.missed_ticks = Math.floor(\n        Math.abs(next_interval_in) / this.interval\n      );\n      this.time += this.missed_ticks * this.interval;\n\n      if (this.go) {\n        this.#tick.call(this);\n      }\n    } else if (this.go) {\n      this.timeout = window.setTimeout(this.#tick.bind(this), next_interval_in);\n    }\n  }\n\n  /**\n   * Called by Tock internally - use start() instead\n   */\n  #startCountdown(duration: number) {\n    this.duration_ms = duration;\n    this.start_time = Date.now();\n    this.time = 0;\n    this.go = true;\n    this.#tick.call(this);\n  }\n\n  /**\n   * Called by Tock internally - use start() instead\n   */\n  #startTimer(start_offset: number) {\n    this.start_time = start_offset || Date.now();\n    this.time = 0;\n    this.go = true;\n    this.#tick.call(this);\n  }\n\n  /**\n   * Reset the clock\n   */\n  reset() {\n    if (this.countdown) {\n      return false;\n    }\n\n    this.stop();\n    this.start_time = 0;\n    this.time = 0;\n  }\n\n  /**\n   * Start the clock.\n   * @param {Various} time Accepts a single \"time\" argument\n   *   which can be in various forms:\n   *   - MM:SS\n   *   - MM:SS:ms or MM:SS.ms\n   *   - HH:MM:SS\n   *   - yyyy-mm-dd HH:MM:SS.ms\n   *   - milliseconds\n   */\n  start(time: string = \"0\") {\n    if (this.go) {\n      return false;\n    }\n\n    const time_int = this.timeToMS(time);\n\n    this.start_time = time_int;\n    this.pause_time = 0;\n\n    if (this.countdown) {\n      this.#startCountdown.call(this, time_int);\n    } else {\n      this.#startTimer.call(this, Date.now() - time_int);\n    }\n  }\n\n  /**\n   * Stop the clock and clear the timeout\n   */\n  stop() {\n    this.pause_time = this.lap();\n    this.go = false;\n\n    clearTimeout(this.timeout);\n\n    if (this.countdown) {\n      this.final_time = this.duration_ms - this.time;\n    } else {\n      this.final_time = Date.now() - this.start_time;\n    }\n  }\n\n  /**\n   * Stop/start the clock.\n   */\n  pause() {\n    if (this.go) {\n      this.pause_time = this.lap();\n      this.stop();\n    } else {\n      if (this.pause_time) {\n        if (this.countdown) {\n          this.#startCountdown.call(this, this.pause_time);\n        } else {\n          this.#startTimer.call(this, Date.now() - this.pause_time);\n        }\n\n        this.pause_time = 0;\n      }\n    }\n  }\n\n  /**\n   * Get the current clock time in ms.\n   * Use with Tock.msToTime() to make it look nice.\n   */\n  lap() {\n    if (this.go) {\n      var now;\n\n      if (this.countdown) {\n        now = this.duration_ms - (Date.now() - this.start_time);\n      } else {\n        now = Date.now() - this.start_time;\n      }\n\n      return now;\n    }\n\n    return this.pause_time || this.final_time;\n  }\n\n  /**\n   * Format milliseconds as a MM:SS.ms string.\n   */\n  msToTime(ms: number): string {\n    var milliseconds = this.zeroPad(ms % MS_PER_SEC, 3),\n      seconds = this.zeroPad(Math.floor((ms / MS_PER_SEC) % 60), 2),\n      minutes = this.zeroPad(Math.floor((ms / MS_PER_MIN) % 60), 2);\n\n    return minutes + \":\" + seconds + \".\" + milliseconds;\n  }\n\n  /**\n   * Pad the left side of a string with zeros up to a given length. I\n   * considered using an NPM package for this but it's probably best not to.\n   */\n  zeroPad(input: number | string, length: number): string {\n    input = input.toString();\n\n    while (input.length < length) {\n      input = \"0\" + input;\n    }\n\n    return input;\n  }\n\n  /**\n   * Format milliseconds as HH:MM:SS or HH:MM:SS:mmm\n   */\n  msToTimecode(ms: number, show_ms: boolean = false): string {\n    var seconds = this.zeroPad(Math.floor((ms / MS_PER_SEC) % 60), 2),\n      minutes = this.zeroPad(Math.floor((ms / MS_PER_MIN) % 60), 2),\n      hours = this.zeroPad(Math.floor(ms / MS_PER_HOUR), 2),\n      millisec = show_ms\n        ? \":\" + this.zeroPad(Math.floor(ms % MS_PER_SEC), 3)\n        : \"\";\n\n    return hours + \":\" + minutes + \":\" + seconds + millisec;\n  }\n\n  /**\n   * Convert a time string to milliseconds\n   *\n   * Possible inputs:\n   * MM:SS\n   * MM:SS:ms or MM:SS.ms\n   * HH:MM:SS\n   * yyyy-mm-dd HH:MM:SS.ms\n   *\n   * A milliseconds input will return it back for safety\n   * If the input cannot be recognized then 0 is returned\n   */\n  timeToMS(time: string): number {\n    // If input is milliseconds integer then return it back\n    if (MILLISECONDS_RE.test(String(time))) {\n      return parseInt(time, 10);\n    }\n\n    let ms;\n    let time_split;\n    let match;\n    let date;\n    const now = new Date();\n\n    if (MM_SS_RE.test(time)) {\n      // If MM:SS\n      time_split = time.split(\":\");\n      ms = parseInt(time_split[0], 10) * MS_PER_MIN;\n      ms += parseInt(time_split[1], 10) * MS_PER_SEC;\n      return ms;\n    }\n\n    match = time.match(MM_SS_ms_OR_HH_MM_SS_RE);\n\n    if (match) {\n      if (match[3].length == 3 || parseInt(match[3], 10) > 59) {\n        // If MM:SS:ms or MM:SS.ms (e.g. 10:10:458 or 10:10.458)\n        ms = parseInt(match[1], 10) * MS_PER_MIN;\n        ms += parseInt(match[2], 10) * MS_PER_SEC;\n        ms += parseInt(match[3], 10);\n\n        return ms;\n      } else {\n        // Then it's HH:MM:SS\n        ms = parseInt(match[1], 10) * MS_PER_HOUR;\n        ms += parseInt(match[2], 10) * MS_PER_MIN;\n        ms += parseInt(match[3], 10) * MS_PER_SEC;\n\n        return ms;\n      }\n    }\n\n    match = time.match(yyyy_mm_dd_HH_MM_SS_ms_RE);\n\n    if (match) {\n      // If yyyy-mm-dd HH:MM:SS or yyyy-mm-dd HH:MM:SS.ms or yyyy-mm-ddTHH:MM:SS.msZ\n      date = new Date();\n      date.setFullYear(parseInt(match[1], 10));\n      date.setMonth(parseInt(match[2], 10));\n      date.setDate(parseInt(match[3], 10));\n      date.setHours(parseInt(match[4], 10));\n      date.setMinutes(parseInt(match[5], 10));\n      date.setSeconds(parseInt(match[6], 10));\n\n      if (typeof match[7] !== \"undefined\") {\n        date.setMilliseconds(parseInt(match[7], 10));\n      }\n\n      ms = Math.max(0, date.getTime() - now.getTime());\n      return ms;\n    }\n\n    // Let's try it as a date string\n    ms = Date.parse(time);\n\n    if (!isNaN(ms)) {\n      // Looks ok\n      return Math.max(0, ms - now.getTime());\n    }\n\n    // Could not recognize input, so start from 0\n    return 0;\n  }\n}\n\nexport default Tock;"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","MILLISECONDS_RE","MM_SS_RE","MM_SS_ms_OR_HH_MM_SS_RE","MS_PER_HOUR","MS_PER_MIN","MS_PER_SEC","yyyy_mm_dd_HH_MM_SS_ms_RE","time","interval","countdown","duration_ms","final_time","go","callback","clearTimeout","timeout","complete","diff","Date","now","start_time","next_interval_in","missed_ticks","Math","floor","abs","window","setTimeout","bind","duration","start_offset","Tock","options","undefined","pause_time","stop","time_int","timeToMS","lap","ms","milliseconds","zeroPad","seconds","input","length","toString","show_ms","minutes","hours","millisec","test","String","parseInt","time_split","match","date","split","setFullYear","setMonth","setDate","setHours","setMinutes","setSeconds","setMilliseconds","max","getTime","parse","isNaN"],"sourceRoot":""}